# 구현 계획: [기능명]

**상태**: 진행 중
**시작일**: YYYY-MM-DD
**최종 수정일**: YYYY-MM-DD
**예상 완료일**: YYYY-MM-DD

---

**필수 지침**: 각 Phase 완료 후:
1. 완료된 태스크 checkbox를 체크
2. 모든 quality gate 검증 명령 실행
3. 모든 quality gate 항목 통과 확인
4. 위의 "최종 수정일" 날짜 업데이트
5. 메모 섹션에 학습 내용 기록
6. 그 후에만 다음 Phase로 진행

**Quality gate를 건너뛰거나 실패한 상태로 진행하지 말 것**

---

## 개요

### 기능 설명
[이 기능이 무엇을 하는지, 왜 필요한지]

### 성공 기준
- [ ] 기준 1
- [ ] 기준 2
- [ ] 기준 3

### 사용자 영향
[이 기능이 사용자 또는 제품에 가져다주는 이점]

---

## 아키텍처 결정 사항

| 결정 | 근거 | Trade-off |
|------|------|-----------|
| [결정 1] | [이 접근 방식을 선택한 이유] | [포기하는 것] |
| [결정 2] | [이 접근 방식을 선택한 이유] | [포기하는 것] |

---

## 의존성

### 시작 전 필요 사항
- [ ] 의존성 1: [설명]
- [ ] 의존성 2: [설명]

### 외부 의존성
- 패키지/라이브러리 1: 버전 X.Y.Z
- 패키지/라이브러리 2: 버전 X.Y.Z

---

## 테스트 전략

### 테스트 접근 방식
**TDD 원칙**: 테스트를 먼저 작성하고, 그 후 테스트를 통과시키도록 구현

### 이 기능의 Test Pyramid
| 테스트 유형 | 커버리지 목표 | 목적 |
|------------|-------------|------|
| **Unit Test** | ≥80% | 비즈니스 로직, 모델, 핵심 알고리즘 |
| **Integration Test** | 핵심 경로 | 컴포넌트 상호작용, 데이터 흐름 |
| **E2E Test** | 주요 사용자 플로우 | 전체 시스템 동작 검증 |

### 테스트 파일 구성
```
test/
├── unit/
│   ├── [domain/business_logic]/
│   └── [data/models]/
├── integration/
│   └── [feature_name]/
└── e2e/
    └── [user_flows]/
```

### Phase별 커버리지 요구사항
- **Phase 1 (기반)**: 핵심 모델/엔티티의 unit test (≥80%)
- **Phase 2 (비즈니스 로직)**: 로직 + repository 테스트 (≥80%)
- **Phase 3 (통합)**: 컴포넌트 integration test (≥70%)
- **Phase 4 (E2E)**: End-to-end 사용자 플로우 테스트 (1개 이상 핵심 경로)

### 테스트 네이밍 규칙
프로젝트의 테스트 프레임워크 규칙을 따릅니다:
```
// 예시 구조 (프레임워크에 맞게 조정):
describe/group: 기능 또는 컴포넌트 이름
  test/it: 테스트 대상 특정 동작
    // Arrange → Act → Assert 패턴
```

---

## 구현 Phase

### Phase 1: [기반 Phase 이름]
**목표**: [이 Phase가 전달하는 구체적인 동작 기능]
**예상 소요 시간**: X 시간
**상태**: 대기 | 진행 중 | 완료

#### 태스크

**RED: 실패하는 테스트를 먼저 작성**
- [ ] **Test 1.1**: [특정 기능]에 대한 unit test 작성
  - 파일: `test/unit/[feature]/[component]_test.*`
  - 예상: 기능이 아직 없으므로 테스트 실패 (red)
  - 상세: 테스트 케이스 포함:
    - Happy path 시나리오
    - Edge case
    - 에러 조건

- [ ] **Test 1.2**: [컴포넌트 상호작용]에 대한 integration test 작성
  - 파일: `test/integration/[feature]_test.*`
  - 예상: 통합이 아직 없으므로 테스트 실패 (red)
  - 상세: [컴포넌트 목록] 간 상호작용 테스트

**GREEN: 테스트를 통과시키도록 구현**
- [ ] **Task 1.3**: [컴포넌트/모듈] 구현
  - 파일: `src/[layer]/[component].*`
  - 목표: 최소한의 코드로 Test 1.1 통과
  - 상세: [구현 노트]

- [ ] **Task 1.4**: [통합/연결 코드] 구현
  - 파일: `src/[layer]/[integration].*`
  - 목표: Test 1.2 통과
  - 상세: [구현 노트]

**REFACTOR: 코드 정리**
- [ ] **Task 1.5**: 코드 품질 개선을 위한 refactor
  - 파일: 이 Phase의 모든 새 코드 검토
  - 목표: 테스트를 깨뜨리지 않으면서 설계 개선
  - 체크리스트:
    - [ ] 중복 제거 (DRY 원칙)
    - [ ] 네이밍 명확성 개선
    - [ ] 재사용 가능한 컴포넌트 추출
    - [ ] 인라인 문서 추가
    - [ ] 필요 시 성능 최적화

#### Quality Gate

**다음 Phase로 진행하기 전에 모든 항목이 통과해야 합니다**

**TDD 준수** (필수):
- [ ] **Red Phase**: 테스트를 먼저 작성했고 초기에 실패함
- [ ] **Green Phase**: 테스트를 통과시키는 프로덕션 코드 작성
- [ ] **Refactor Phase**: 테스트가 통과하는 상태에서 코드 개선
- [ ] **커버리지 확인**: 테스트 커버리지가 요구사항 충족
  ```bash
  # 예시 명령어 (테스트 프레임워크에 맞게 조정):
  # npm test -- --coverage
  # pytest --cov=src --cov-report=html
  # dotnet test /p:CollectCoverage=true
  # go test -cover ./...

  [프로젝트의 커버리지 명령어]
  ```

**빌드 & 테스트**:
- [ ] **빌드**: 프로젝트가 에러 없이 빌드/컴파일됨
- [ ] **모든 테스트 통과**: 테스트 100% 통과 (skip된 테스트 없음)
- [ ] **테스트 성능**: 테스트 suite가 허용 가능한 시간 내 완료
- [ ] **Flaky 테스트 없음**: 테스트가 일관되게 통과 (3회 이상 실행)

**코드 품질**:
- [ ] **Lint**: lint 에러 또는 경고 없음
- [ ] **포맷팅**: 프로젝트 표준에 맞게 코드 포맷됨
- [ ] **Type 안전성**: type 검사 통과 (해당 시)
- [ ] **정적 분석**: 정적 분석 도구에서 치명적 이슈 없음

**보안 & 성능**:
- [ ] **의존성**: 알려진 보안 취약점 없음
- [ ] **성능**: 성능 regression 없음
- [ ] **메모리**: 메모리 누수 또는 리소스 이슈 없음
- [ ] **에러 처리**: 적절한 에러 처리 구현됨

**문서화**:
- [ ] **코드 주석**: 복잡한 로직에 문서화됨
- [ ] **API 문서**: public interface 문서화됨
- [ ] **README**: 필요 시 사용 안내 업데이트됨

**수동 테스트**:
- [ ] **기능**: 기능이 예상대로 동작
- [ ] **Edge Case**: 경계 조건 테스트됨
- [ ] **에러 상태**: 에러 처리 검증됨

**검증 명령어** (프로젝트에 맞게 커스터마이즈):
```bash
# 테스트 명령어
[테스트 실행 명령어]

# 커버리지 확인
[커버리지 명령어]

# 코드 품질
[lint 명령어]
[포맷터 확인 명령어]
[type 검사 명령어]

# 빌드 검증
[빌드 명령어]

# 보안 감사
[의존성 감사 명령어]

# 생태계별 예시:
# JavaScript/TypeScript: npm test && npm run lint && npm run type-check
# Python: pytest && black --check . && mypy .
# Java: mvn test && mvn checkstyle:check
# Go: go test ./... && golangci-lint run
# .NET: dotnet test && dotnet format --verify-no-changes
# Ruby: bundle exec rspec && rubocop
# Rust: cargo test && cargo clippy
```

**수동 테스트 체크리스트**:
- [ ] 테스트 케이스 1: [검증할 특정 시나리오]
- [ ] 테스트 케이스 2: [검증할 edge case]
- [ ] 테스트 케이스 3: [검증할 에러 처리]

---

### Phase 2: [핵심 기능 Phase 이름]
**목표**: [구체적인 전달물]
**예상 소요 시간**: X 시간
**상태**: 대기 | 진행 중 | 완료

#### 태스크

**RED: 실패하는 테스트를 먼저 작성**
- [ ] **Test 2.1**: [특정 기능]에 대한 unit test 작성
  - 파일: `test/unit/[feature]/[component]_test.*`
  - 예상: 기능이 아직 없으므로 테스트 실패 (red)
  - 상세: 테스트 케이스 포함:
    - Happy path 시나리오
    - Edge case
    - 에러 조건

- [ ] **Test 2.2**: [컴포넌트 상호작용]에 대한 integration test 작성
  - 파일: `test/integration/[feature]_test.*`
  - 예상: 통합이 아직 없으므로 테스트 실패 (red)
  - 상세: [컴포넌트 목록] 간 상호작용 테스트

**GREEN: 테스트를 통과시키도록 구현**
- [ ] **Task 2.3**: [컴포넌트/모듈] 구현
  - 파일: `src/[layer]/[component].*`
  - 목표: 최소한의 코드로 Test 2.1 통과
  - 상세: [구현 노트]

- [ ] **Task 2.4**: [통합/연결 코드] 구현
  - 파일: `src/[layer]/[integration].*`
  - 목표: Test 2.2 통과
  - 상세: [구현 노트]

**REFACTOR: 코드 정리**
- [ ] **Task 2.5**: 코드 품질 개선을 위한 refactor
  - 파일: 이 Phase의 모든 새 코드 검토
  - 목표: 테스트를 깨뜨리지 않으면서 설계 개선
  - 체크리스트:
    - [ ] 중복 제거 (DRY 원칙)
    - [ ] 네이밍 명확성 개선
    - [ ] 재사용 가능한 컴포넌트 추출
    - [ ] 인라인 문서 추가
    - [ ] 필요 시 성능 최적화

#### Quality Gate

**다음 Phase로 진행하기 전에 모든 항목이 통과해야 합니다**

**TDD 준수** (필수):
- [ ] **Red Phase**: 테스트를 먼저 작성했고 초기에 실패함
- [ ] **Green Phase**: 테스트를 통과시키는 프로덕션 코드 작성
- [ ] **Refactor Phase**: 테스트가 통과하는 상태에서 코드 개선
- [ ] **커버리지 확인**: 테스트 커버리지가 요구사항 충족

**빌드 & 테스트**:
- [ ] **빌드**: 프로젝트가 에러 없이 빌드/컴파일됨
- [ ] **모든 테스트 통과**: 테스트 100% 통과 (skip된 테스트 없음)
- [ ] **테스트 성능**: 테스트 suite가 허용 가능한 시간 내 완료
- [ ] **Flaky 테스트 없음**: 테스트가 일관되게 통과 (3회 이상 실행)

**코드 품질**:
- [ ] **Lint**: lint 에러 또는 경고 없음
- [ ] **포맷팅**: 프로젝트 표준에 맞게 코드 포맷됨
- [ ] **Type 안전성**: type 검사 통과 (해당 시)
- [ ] **정적 분석**: 정적 분석 도구에서 치명적 이슈 없음

**보안 & 성능**:
- [ ] **의존성**: 알려진 보안 취약점 없음
- [ ] **성능**: 성능 regression 없음
- [ ] **메모리**: 메모리 누수 또는 리소스 이슈 없음
- [ ] **에러 처리**: 적절한 에러 처리 구현됨

**문서화**:
- [ ] **코드 주석**: 복잡한 로직에 문서화됨
- [ ] **API 문서**: public interface 문서화됨
- [ ] **README**: 필요 시 사용 안내 업데이트됨

**수동 테스트**:
- [ ] **기능**: 기능이 예상대로 동작
- [ ] **Edge Case**: 경계 조건 테스트됨
- [ ] **에러 상태**: 에러 처리 검증됨

**검증 명령어**:
```bash
[Phase 1과 동일 - 프로젝트에 맞게 커스터마이즈]
```

**수동 테스트 체크리스트**:
- [ ] 테스트 케이스 1: [검증할 특정 시나리오]
- [ ] 테스트 케이스 2: [검증할 edge case]
- [ ] 테스트 케이스 3: [검증할 에러 처리]

---

### Phase 3: [확장 Phase 이름]
**목표**: [구체적인 전달물]
**예상 소요 시간**: X 시간
**상태**: 대기 | 진행 중 | 완료

#### 태스크

**RED: 실패하는 테스트를 먼저 작성**
- [ ] **Test 3.1**: [특정 기능]에 대한 unit test 작성
  - 파일: `test/unit/[feature]/[component]_test.*`
  - 예상: 기능이 아직 없으므로 테스트 실패 (red)
  - 상세: 테스트 케이스 포함:
    - Happy path 시나리오
    - Edge case
    - 에러 조건

- [ ] **Test 3.2**: [컴포넌트 상호작용]에 대한 integration test 작성
  - 파일: `test/integration/[feature]_test.*`
  - 예상: 통합이 아직 없으므로 테스트 실패 (red)
  - 상세: [컴포넌트 목록] 간 상호작용 테스트

**GREEN: 테스트를 통과시키도록 구현**
- [ ] **Task 3.3**: [컴포넌트/모듈] 구현
  - 파일: `src/[layer]/[component].*`
  - 목표: 최소한의 코드로 Test 3.1 통과
  - 상세: [구현 노트]

- [ ] **Task 3.4**: [통합/연결 코드] 구현
  - 파일: `src/[layer]/[integration].*`
  - 목표: Test 3.2 통과
  - 상세: [구현 노트]

**REFACTOR: 코드 정리**
- [ ] **Task 3.5**: 코드 품질 개선을 위한 refactor
  - 파일: 이 Phase의 모든 새 코드 검토
  - 목표: 테스트를 깨뜨리지 않으면서 설계 개선
  - 체크리스트:
    - [ ] 중복 제거 (DRY 원칙)
    - [ ] 네이밍 명확성 개선
    - [ ] 재사용 가능한 컴포넌트 추출
    - [ ] 인라인 문서 추가
    - [ ] 필요 시 성능 최적화

#### Quality Gate

**모든 항목이 통과해야 합니다**

**TDD 준수** (필수):
- [ ] **Red Phase**: 테스트를 먼저 작성했고 초기에 실패함
- [ ] **Green Phase**: 테스트를 통과시키는 프로덕션 코드 작성
- [ ] **Refactor Phase**: 테스트가 통과하는 상태에서 코드 개선
- [ ] **커버리지 확인**: 테스트 커버리지가 요구사항 충족

**빌드 & 테스트**:
- [ ] **빌드**: 프로젝트가 에러 없이 빌드/컴파일됨
- [ ] **모든 테스트 통과**: 테스트 100% 통과 (skip된 테스트 없음)
- [ ] **테스트 성능**: 테스트 suite가 허용 가능한 시간 내 완료
- [ ] **Flaky 테스트 없음**: 테스트가 일관되게 통과 (3회 이상 실행)

**코드 품질**:
- [ ] **Lint**: lint 에러 또는 경고 없음
- [ ] **포맷팅**: 프로젝트 표준에 맞게 코드 포맷됨
- [ ] **Type 안전성**: type 검사 통과 (해당 시)
- [ ] **정적 분석**: 정적 분석 도구에서 치명적 이슈 없음

**보안 & 성능**:
- [ ] **의존성**: 알려진 보안 취약점 없음
- [ ] **성능**: 성능 regression 없음
- [ ] **메모리**: 메모리 누수 또는 리소스 이슈 없음
- [ ] **에러 처리**: 적절한 에러 처리 구현됨

**문서화**:
- [ ] **코드 주석**: 복잡한 로직에 문서화됨
- [ ] **API 문서**: public interface 문서화됨
- [ ] **README**: 필요 시 사용 안내 업데이트됨

**수동 테스트**:
- [ ] **기능**: 기능이 예상대로 동작
- [ ] **Edge Case**: 경계 조건 테스트됨
- [ ] **에러 상태**: 에러 처리 검증됨

**검증 명령어**:
```bash
[이전 Phase와 동일 - 프로젝트에 맞게 커스터마이즈]
```

**수동 테스트 체크리스트**:
- [ ] 테스트 케이스 1: [검증할 특정 시나리오]
- [ ] 테스트 케이스 2: [검증할 edge case]
- [ ] 테스트 케이스 3: [검증할 에러 처리]

---

## 리스크 평가

| 리스크 | 발생 확률 | 영향도 | 완화 전략 |
|--------|----------|--------|----------|
| [리스크 1: 예) API 변경으로 연동 깨짐] | 낮음/중간/높음 | 낮음/중간/높음 | [구체적인 완화 단계] |
| [리스크 2: 예) 성능 저하] | 낮음/중간/높음 | 낮음/중간/높음 | [구체적인 완화 단계] |
| [리스크 3: 예) 데이터베이스 migration 이슈] | 낮음/중간/높음 | 낮음/중간/높음 | [구체적인 완화 단계] |

---

## Rollback 전략

### Phase 1 실패 시
**되돌리기 단계**:
- 코드 변경 취소: [파일 목록]
- 설정 복원: [특정 설정]
- 의존성 제거: [추가된 것이 있다면]

### Phase 2 실패 시
**되돌리기 단계**:
- Phase 1 완료 상태로 복원
- 변경 취소: [파일 목록]
- 데이터베이스 rollback: [해당 시]

### Phase 3 실패 시
**되돌리기 단계**:
- Phase 2 완료 상태로 복원
- [추가 정리 단계]

---

## 진행 상황 추적

### 완료 현황
- **Phase 1**: 0% | 50% | 100%
- **Phase 2**: 0% | 50% | 100%
- **Phase 3**: 0% | 50% | 100%

**전체 진행률**: X% 완료

### 시간 추적
| Phase | 예상 | 실제 | 차이 |
|-------|------|------|------|
| Phase 1 | X 시간 | Y 시간 | +/- Z 시간 |
| Phase 2 | X 시간 | - | - |
| Phase 3 | X 시간 | - | - |
| **합계** | X 시간 | Y 시간 | +/- Z 시간 |

---

## 메모 & 학습 내용

### 구현 메모
- [구현 중 발견한 인사이트 추가]
- [원래 계획에서 벗어난 결정 사항 기록]
- [도움이 된 디버깅 발견 기록]

### 발생한 Blocker
- **Blocker 1**: [설명] → [해결 방법]
- **Blocker 2**: [설명] → [해결 방법]

### 향후 계획을 위한 개선점
- [다음에는 무엇을 다르게 할 것인가?]
- [특히 잘 동작한 것은?]

---

## 참고 자료

### 문서
- [관련 문서 링크]
- [API 레퍼런스 링크]
- [디자인 목업 링크]

### 관련 이슈
- Issue #X: [설명]
- PR #Y: [설명]

---

## 최종 체크리스트

**계획을 완료로 표시하기 전에**:
- [ ] 모든 Phase가 quality gate를 통과하여 완료됨
- [ ] 전체 integration test 수행됨
- [ ] 문서 업데이트됨
- [ ] 성능 벤치마크가 목표치 충족
- [ ] 보안 리뷰 완료됨
- [ ] 접근성 요구사항 충족 (UI 기능인 경우)
- [ ] 모든 이해관계자에게 알림 완료
- [ ] 계획 문서가 향후 참고를 위해 아카이브됨

---

## TDD 예시 워크플로우

### 예시: 사용자 인증 기능 추가

**Phase 1: RED (실패하는 테스트 작성)**

```
# 의사 코드 - 테스트 프레임워크에 맞게 조정

test "사용자 자격 증명을 검증해야 함":
  // Arrange
  authService = new AuthService(mockDatabase)
  validCredentials = {username: "user", password: "pass"}

  // Act
  result = authService.authenticate(validCredentials)

  // Assert
  expect(result.isSuccess).toBe(true)
  expect(result.user).toBeDefined()
  // 테스트 실패 - AuthService가 아직 존재하지 않음
```

**Phase 2: GREEN (최소한의 구현)**

```
class AuthService:
  function authenticate(credentials):
    // 테스트를 통과시키는 최소한의 코드
    user = database.findUser(credentials.username)
    if user AND user.password == credentials.password:
      return Success(user)
    return Failure("잘못된 자격 증명")
    // 테스트 통과 - 최소 기능 동작
```

**Phase 3: REFACTOR (설계 개선)**

```
class AuthService:
  function authenticate(credentials):
    // 유효성 검사 추가
    if not this.validateCredentials(credentials):
      return Failure("잘못된 입력")

    // 에러 처리 추가
    try:
      user = database.findUser(credentials.username)

      // 안전한 비밀번호 비교 사용
      if user AND this.secureCompare(user.password, credentials.password):
        return Success(user)

      return Failure("잘못된 자격 증명")
    catch DatabaseError as error:
      logger.error(error)
      return Failure("인증 실패")
    // 테스트 여전히 통과 - 코드 품질 향상됨
```

### TDD Red-Green-Refactor 사이클 시각화

```
Phase 1: RED
├── 기능 X에 대한 테스트 작성
├── 테스트 실행 → 실패
└── Commit: "기능 X에 대한 실패하는 테스트 추가"

Phase 2: GREEN
├── 최소한의 코드 작성
├── 테스트 실행 → 통과
└── Commit: "테스트를 통과시키도록 X 구현"

Phase 3: REFACTOR
├── 코드 품질 개선
├── 테스트 실행 → 여전히 통과
├── 헬퍼 메서드 추출
├── 테스트 실행 → 여전히 통과
├── 네이밍 개선
├── 테스트 실행 → 여전히 통과
└── Commit: "더 나은 설계를 위해 X refactor"

다음 기능으로 반복 →
```

### 이 접근 방식의 이점

**안전성**: 테스트가 regression을 즉시 감지
**설계**: 테스트가 API 설계를 먼저 생각하게 강제
**문서화**: 테스트가 예상 동작을 문서화
**자신감**: 깨뜨릴 걱정 없이 refactor 가능
**품질**: 첫날부터 높은 코드 커버리지
**디버깅**: 실패가 정확한 문제 영역을 지목

---

**계획 상태**: 진행 중
**다음 액션**: [다음에 일어나야 할 것]
**Blocked By**: [현재 blocker] 또는 없음
